{
    "version": "https://jsonfeed.org/version/1",
    "title": "The Silence of the RAM",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "nail.e's Hacker Handbook ",
    "icon": "http://localhost:4000/assets/images/apple-touch-icon.png",
    "favicon": "http://localhost:4000/assets/images/favicon.png",
    "expired": false,
    
    "author":  {
        "name": "The Silence of the RAM",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://localhost:4000/in-search-of-amongi-using-rust-and-chudnovskys-algorithm/",
            "title": "In search of Amongi using Rust and Chudnovsky's Algorithm",
            "summary": null,
            "content_text": "Pi has always been 3.14159 to me and to everyone else really, it’s only nerds who’d want to know pi up to its 100th or 1000th digit while its your supernerds who’d be searching for pi up to the millionth digit and well, I’m a supernerd (when I want to).So I was bored one summers day and way too done with the monotony of math and physics revision and opened up YouTube and the first video that piqued my interest was Stand-Up Math’s legendary video of finding Among Us in Pi. This Einsteinian ingenuity of a video warrants its own place in the annals of history for finding the meaning of life, death and everything in between but also raised a question in my head: how many Amongi are there in pi?It’s 4.Anyways, the code consisted of a function converting the first million digits of pi (removing the 3.) into binary then writing the binary output to a text file. Another function read from the file to search for the string “0111110011110101” or “1010111100111110”. This was quite easy but it led me to a much cooler discovery.Chudnovsky’s AlgorithmChudnovsky’s Algorithm was formulated by the Chudnovsky brothers in 1988 based on Ramanujan’s pi formulae and goddamn is it interesting. I’m no mathematician but I’ll attempt to explain it the best I can.So, using a generalized hypergeometric function:\\[\\begin{equation} _pF_q\\left( \\begin{array}{c} a_1, a_2, \\ldots, a_p \\\\ b_1, b_2, \\ldots, b_q \\end{array}; z \\right) = \\sum_{n=0}^{\\infty} \\frac{(a_1)_n (a_2)_n \\cdots (a_p)_n}{(b_1)_n (b_2)_n \\cdots (b_q)_n} \\frac{z^n}{n!} \\end{equation}\\]The Chudnovsky algorithm uses the 9th Heegner number ($-163$) which is an integer which is divisible by no square number other than 1 and is part of a finite field of imaginary numbers as well as the $j$-function which is a function of a complex variable on the imaginary, positive-only plane (also known as the upper-half plane) of complex numbers to result in:\\[\\pi = 426880 \\sqrt{10005} \\sum_{k=0}^{\\infty} \\frac{(6k)!(545140134k + 13591409)}{(3k)!(k!)^3(-262537412640768000)^k}\\]This is the Chudnovsky’s algorithm which probably works on a graphing calculator or on pen and paper but it needs some work to be applied on Rust. More on this later.My AttemptI’ve recently become enticed with Rust and its intricacies, almost unhealthily as well. It’s speed and simplicity paired with how readable it is. It’s like if you took C’s control, power and processing and took Python’s syntax and readability and created a love child.Again, I’m no mathematician, so translating mathematical equations into code was a bit daunting. However, Rust’s made the process more manageable. In crafting this implementation, I began by initializing variables to accommodate the dynamic nature of Chudnovsky’s algorithm. Using Float type from rug - a library for large numbers operations - helps with precise calculations for longer numbers.// From lib.rs. File available on GitHub#![warn(clippy::all, clippy::pedantic, missing_docs)]use rug::{ops::Pow, Float};#[must_use]pub fn pi(prec: u32, its: u32) -&gt; Float {    // Define the constants    const A: u32 = 42_68_80;    const B: u32 = 10_005;    const K: u32 = 6;    const K_S: u32 = 12;    const L: u32 = 13_59_14_09;    const L_S: u32 = 545_140_134;    const M: u32 = 1;    const X: u32 = 1;    const X_S: i64 = -262_537_412_640_768_000;    const S: u32 = 0;    // Initialize the values    let a = Float::with_val(prec, A);    let b = Float::with_val(prec, B).sqrt();    let c = Float::with_val(prec, &amp;a * &amp;b);    let mut k = Float::with_val(prec, K);    let k_s = Float::with_val(prec, K_S);    let mut l = Float::with_val(prec, L);    let l_s = Float::with_val(prec, L_S);    let mut m = Float::with_val(prec, M);    let mut x = Float::with_val(prec, X);    let x_s = Float::with_val(prec, X_S);    let mut s = Float::with_val(prec, S);    // Iterate    for q in 0..its {        // S = S + M_q * L_q / X_q        s += Float::with_val(prec, &amp;m * &amp;l) / &amp;x;        // M_q = M_q * (K_q^3 - 16 * K_q) / (q + 1)^3        m *= (k.clone().pow(3) - 16 * k.clone()) / Float::with_val(prec, (q + 1).pow(3));        // Update K_q, L_q, and X_q        k += &amp;k_s;        l += &amp;l_s;        x *= &amp;x_s;    }    // C * (1 / S)    s = Float::with_val(prec, 1) / &amp;s;    // Pi    Float::with_val(prec, &amp;c) * &amp;s}Chudnovsky’s algorithm constantly interates, each progressively searching the approximation of pi and two fundamental things that Rust achieved was accuracy and speed. Rust’s Float ensures that every operation maintains point-bit precision up to 64 bits.// From main.rs. File available on GitHubmod lib;use lib::pi;use std::env;// Edit this for precisionconst PRECISION: u32 = 1000000;// Default number of iterationsconst ITERATIONS: u32 = 1;fn main() {    // Command line arguments    let args: Vec&lt;_&gt; = env::args().collect();    // Make decisions based on the number of arguments    match args.len() {        1 =&gt; {            println!(\"Approximation: {:?}\", pi(PRECISION, ITERATIONS));            println!(\"Precision:     {:?}\", PRECISION);            println!(\"Iterations:    {:?}\", ITERATIONS);        }        2 =&gt; {            let precision = args[1]                .parse::&lt;u32&gt;()                .expect(\"Precision must be a positive integer!\");            if precision &lt;= 0 {                panic!(\"Precision must be a positive integer!\");            } else {                println!(\"Approximation: {:?}\", pi(precision as u32, ITERATIONS));                println!(\"Precision:  {:?}\", precision);                println!(\"Iterations: {:?}\", ITERATIONS);            }        }        3 =&gt; {            let precision = args[1]                .parse::&lt;u32&gt;()                .expect(\"Precision must be a positive integer!\");            let iterations = args[2]                .parse::&lt;u32&gt;()                .expect(\"Number of iterations must be a positive integer!\");            if precision &lt;= 0 {                panic!(\"Precision must be a positive integer!\");            } else if iterations &lt;= 0 {                panic!(\"Number of iterations must be a positive integer!\");            } else {                println!(                    \"Approximation: {:?}\",                    pi(precision as u32, iterations as u32)                );                println!(\"Precision:  {:?}\", precision);                println!(\"Iterations: {:?}\", iterations);            }        }        _ =&gt; panic!(\"Redundant argument.\"),    }}To enhance utility, this thing runs on CLI using env, allowing to specify the desired precision and number of iterations as straightforward command line arguments. Moreover, basic error handling exists, ensuring that a user can’t shoot themselves in the foot.[nail_@nailCPU src]$ cargo run 1000 1warning: found module declaration for lib.rs  --&gt; src/main.rs:14:1   |14 | mod lib;   | ^^^^^^^^   |   = note: lib.rs is the root of this crate's library target   = help: to refer to it from other targets, use the library's name as the path   = note: `#[warn(special_module_name)]` on by defaultwarning: `chudnovskys-amongii` (bin \"chudnovskys-amongii\") generated 1 warning    Finished dev [unoptimized + debuginfo] target(s) in 0.16s     Running `/home/nail_/Documents/Programming/chudnovskys-amongii/target/debug/chudnovskys-amongii 1000 1`Approximation: 3.141592653589734207668453591578298340762233260915706590894145498737666209401659108066117347469689757798160379655566278035801345995935132861731766159828062231080441973785312530565152115747085933831774415457744154596022745876277128465914181337399228595357841129880883782421267946896335292166769473366196807151594471515944Precision:  1000Iterations: 1It’s not perfect sure, but it sure does work. This small project really helped me wrap my head around Rust and Math (even though Math is a fluke in school) so go ahead and give it a try!Links  Github Page  Rug Library  Stand-Up Math’s Video",
            "content_html": "<p>Pi has always been 3.14159 to me and to everyone else really, it’s only nerds who’d want to know pi up to its 100th or 1000th digit while its your supernerds who’d be searching for pi up to the millionth digit and well, I’m a supernerd (when I want to).</p><p>So I was bored one summers day and way too done with the monotony of math and physics revision and opened up YouTube and the first video that piqued my interest was Stand-Up Math’s legendary video of finding Among Us in Pi. This Einsteinian ingenuity of a video warrants its own place in the annals of history for finding the meaning of life, death and everything in between but also raised a question in my head: how many Amongi are there in pi?</p><p>It’s 4.</p><p>Anyways, the code consisted of a function converting the first million digits of pi (removing the <code class=\"language-plaintext highlighter-rouge\">3</code>.) into binary then writing the binary output to a text file. Another function read from the file to search for the string “0111110011110101” or “1010111100111110”. This was quite easy but it led me to a much cooler discovery.</p><h2 id=\"chudnovskys-algorithm\">Chudnovsky’s Algorithm</h2><p>Chudnovsky’s Algorithm was formulated by the Chudnovsky brothers in 1988 based on Ramanujan’s pi formulae and goddamn is it interesting. I’m no mathematician but I’ll attempt to explain it the best I can.</p><p>So, using a generalized hypergeometric function:</p>\\[\\begin{equation} _pF_q\\left( \\begin{array}{c} a_1, a_2, \\ldots, a_p \\\\ b_1, b_2, \\ldots, b_q \\end{array}; z \\right) = \\sum_{n=0}^{\\infty} \\frac{(a_1)_n (a_2)_n \\cdots (a_p)_n}{(b_1)_n (b_2)_n \\cdots (b_q)_n} \\frac{z^n}{n!} \\end{equation}\\]<p>The Chudnovsky algorithm uses the 9th Heegner number ($-163$) which is an integer which is divisible by no square number other than 1 and is part of a finite field of imaginary numbers as well as the $j$-function which is a function of a complex variable on the imaginary, positive-only plane (also known as the upper-half plane) of complex numbers to result in:</p>\\[\\pi = 426880 \\sqrt{10005} \\sum_{k=0}^{\\infty} \\frac{(6k)!(545140134k + 13591409)}{(3k)!(k!)^3(-262537412640768000)^k}\\]<p>This is the Chudnovsky’s algorithm which probably works on a graphing calculator or on pen and paper but it needs some work to be applied on Rust. More on this later.</p><h2 id=\"my-attempt\">My Attempt</h2><p>I’ve recently become enticed with Rust and its intricacies, almost unhealthily as well. It’s speed and simplicity paired with how readable it is. It’s like if you took C’s control, power and processing and took Python’s syntax and readability and created a love child.</p><p>Again, I’m no mathematician, so translating mathematical equations into code was a bit daunting. However, Rust’s made the process more manageable. In crafting this implementation, I began by initializing variables to accommodate the dynamic nature of Chudnovsky’s algorithm. Using <code class=\"language-plaintext highlighter-rouge\">Float</code> type from <code class=\"language-plaintext highlighter-rouge\">rug</code> - a library for large numbers operations - helps with precise calculations for longer numbers.</p><figure class=\"highlight\"><pre><code class=\"language-rust\" data-lang=\"rust\"><span class=\"c\">// From lib.rs. File available on GitHub</span><span class=\"nd\">#![warn(clippy::all,</span> <span class=\"nd\">clippy::pedantic,</span> <span class=\"nd\">missing_docs)]</span><span class=\"k\">use</span> <span class=\"nn\">rug</span><span class=\"p\">::{</span><span class=\"nn\">ops</span><span class=\"p\">::</span><span class=\"n\">Pow</span><span class=\"p\">,</span> <span class=\"n\">Float</span><span class=\"p\">};</span><span class=\"nd\">#[must_use]</span><span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"nf\">pi</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">:</span> <span class=\"nb\">u32</span><span class=\"p\">,</span> <span class=\"n\">its</span><span class=\"p\">:</span> <span class=\"nb\">u32</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">Float</span> <span class=\"p\">{</span>    <span class=\"c\">// Define the constants</span>    <span class=\"k\">const</span> <span class=\"n\">A</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">42_68_80</span><span class=\"p\">;</span>    <span class=\"k\">const</span> <span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">10_005</span><span class=\"p\">;</span>    <span class=\"k\">const</span> <span class=\"n\">K</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">6</span><span class=\"p\">;</span>    <span class=\"k\">const</span> <span class=\"n\">K_S</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">12</span><span class=\"p\">;</span>    <span class=\"k\">const</span> <span class=\"n\">L</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">13_59_14_09</span><span class=\"p\">;</span>    <span class=\"k\">const</span> <span class=\"n\">L_S</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">545_140_134</span><span class=\"p\">;</span>    <span class=\"k\">const</span> <span class=\"n\">M</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>    <span class=\"k\">const</span> <span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>    <span class=\"k\">const</span> <span class=\"n\">X_S</span><span class=\"p\">:</span> <span class=\"nb\">i64</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">262_537_412_640_768_000</span><span class=\"p\">;</span>    <span class=\"k\">const</span> <span class=\"n\">S</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>    <span class=\"c\">// Initialize the values</span>    <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">);</span>    <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">)</span><span class=\"nf\">.sqrt</span><span class=\"p\">();</span>    <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">a</span> <span class=\"o\">*</span> <span class=\"o\">&amp;</span><span class=\"n\">b</span><span class=\"p\">);</span>    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">K</span><span class=\"p\">);</span>    <span class=\"k\">let</span> <span class=\"n\">k_s</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">K_S</span><span class=\"p\">);</span>    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">L</span><span class=\"p\">);</span>    <span class=\"k\">let</span> <span class=\"n\">l_s</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">L_S</span><span class=\"p\">);</span>    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">M</span><span class=\"p\">);</span>    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">X</span><span class=\"p\">);</span>    <span class=\"k\">let</span> <span class=\"n\">x_s</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">X_S</span><span class=\"p\">);</span>    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">);</span>    <span class=\"c\">// Iterate</span>    <span class=\"k\">for</span> <span class=\"n\">q</span> <span class=\"n\">in</span> <span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"n\">its</span> <span class=\"p\">{</span>        <span class=\"c\">// S = S + M_q * L_q / X_q</span>        <span class=\"n\">s</span> <span class=\"o\">+=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">m</span> <span class=\"o\">*</span> <span class=\"o\">&amp;</span><span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">;</span>        <span class=\"c\">// M_q = M_q * (K_q^3 - 16 * K_q) / (q + 1)^3</span>        <span class=\"n\">m</span> <span class=\"o\">*=</span> <span class=\"p\">(</span><span class=\"n\">k</span><span class=\"nf\">.clone</span><span class=\"p\">()</span><span class=\"nf\">.pow</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">16</span> <span class=\"o\">*</span> <span class=\"n\">k</span><span class=\"nf\">.clone</span><span class=\"p\">())</span> <span class=\"o\">/</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"nf\">.pow</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">));</span>        <span class=\"c\">// Update K_q, L_q, and X_q</span>        <span class=\"n\">k</span> <span class=\"o\">+=</span> <span class=\"o\">&amp;</span><span class=\"n\">k_s</span><span class=\"p\">;</span>        <span class=\"n\">l</span> <span class=\"o\">+=</span> <span class=\"o\">&amp;</span><span class=\"n\">l_s</span><span class=\"p\">;</span>        <span class=\"n\">x</span> <span class=\"o\">*=</span> <span class=\"o\">&amp;</span><span class=\"n\">x_s</span><span class=\"p\">;</span>    <span class=\"p\">}</span>    <span class=\"c\">// C * (1 / S)</span>    <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"o\">&amp;</span><span class=\"n\">s</span><span class=\"p\">;</span>    <span class=\"c\">// Pi</span>    <span class=\"nn\">Float</span><span class=\"p\">::</span><span class=\"nf\">with_val</span><span class=\"p\">(</span><span class=\"n\">prec</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">c</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"o\">&amp;</span><span class=\"n\">s</span><span class=\"p\">}</span></code></pre></figure><p>Chudnovsky’s algorithm constantly interates, each progressively searching the approximation of pi and two fundamental things that Rust achieved was accuracy and speed. Rust’s <code class=\"language-plaintext highlighter-rouge\">Float</code> ensures that every operation maintains point-bit precision up to 64 bits.</p><figure class=\"highlight\"><pre><code class=\"language-rust\" data-lang=\"rust\"><span class=\"c\">// From main.rs. File available on GitHub</span><span class=\"k\">mod</span> <span class=\"n\">lib</span><span class=\"p\">;</span><span class=\"k\">use</span> <span class=\"nn\">lib</span><span class=\"p\">::</span><span class=\"n\">pi</span><span class=\"p\">;</span><span class=\"k\">use</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"n\">env</span><span class=\"p\">;</span><span class=\"c\">// Edit this for precision</span><span class=\"k\">const</span> <span class=\"n\">PRECISION</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">1000000</span><span class=\"p\">;</span><span class=\"c\">// Default number of iterations</span><span class=\"k\">const</span> <span class=\"n\">ITERATIONS</span><span class=\"p\">:</span> <span class=\"nb\">u32</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"c\">// Command line arguments</span>    <span class=\"k\">let</span> <span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"mi\">_</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"nn\">env</span><span class=\"p\">::</span><span class=\"nf\">args</span><span class=\"p\">()</span><span class=\"nf\">.collect</span><span class=\"p\">();</span>    <span class=\"c\">// Make decisions based on the number of arguments</span>    <span class=\"k\">match</span> <span class=\"n\">args</span><span class=\"nf\">.len</span><span class=\"p\">()</span> <span class=\"p\">{</span>        <span class=\"mi\">1</span> <span class=\"k\">=&gt;</span> <span class=\"p\">{</span>            <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Approximation: {:?}\"</span><span class=\"p\">,</span> <span class=\"nf\">pi</span><span class=\"p\">(</span><span class=\"n\">PRECISION</span><span class=\"p\">,</span> <span class=\"n\">ITERATIONS</span><span class=\"p\">));</span>            <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Precision:     {:?}\"</span><span class=\"p\">,</span> <span class=\"n\">PRECISION</span><span class=\"p\">);</span>            <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Iterations:    {:?}\"</span><span class=\"p\">,</span> <span class=\"n\">ITERATIONS</span><span class=\"p\">);</span>        <span class=\"p\">}</span>        <span class=\"mi\">2</span> <span class=\"k\">=&gt;</span> <span class=\"p\">{</span>            <span class=\"k\">let</span> <span class=\"n\">precision</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>                <span class=\"py\">.parse</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">()</span>                <span class=\"nf\">.expect</span><span class=\"p\">(</span><span class=\"s\">\"Precision must be a positive integer!\"</span><span class=\"p\">);</span>            <span class=\"k\">if</span> <span class=\"n\">precision</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>                <span class=\"nd\">panic!</span><span class=\"p\">(</span><span class=\"s\">\"Precision must be a positive integer!\"</span><span class=\"p\">);</span>            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>                <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Approximation: {:?}\"</span><span class=\"p\">,</span> <span class=\"nf\">pi</span><span class=\"p\">(</span><span class=\"n\">precision</span> <span class=\"k\">as</span> <span class=\"nb\">u32</span><span class=\"p\">,</span> <span class=\"n\">ITERATIONS</span><span class=\"p\">));</span>                <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Precision:  {:?}\"</span><span class=\"p\">,</span> <span class=\"n\">precision</span><span class=\"p\">);</span>                <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Iterations: {:?}\"</span><span class=\"p\">,</span> <span class=\"n\">ITERATIONS</span><span class=\"p\">);</span>            <span class=\"p\">}</span>        <span class=\"p\">}</span>        <span class=\"mi\">3</span> <span class=\"k\">=&gt;</span> <span class=\"p\">{</span>            <span class=\"k\">let</span> <span class=\"n\">precision</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>                <span class=\"py\">.parse</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">()</span>                <span class=\"nf\">.expect</span><span class=\"p\">(</span><span class=\"s\">\"Precision must be a positive integer!\"</span><span class=\"p\">);</span>            <span class=\"k\">let</span> <span class=\"n\">iterations</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>                <span class=\"py\">.parse</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">()</span>                <span class=\"nf\">.expect</span><span class=\"p\">(</span><span class=\"s\">\"Number of iterations must be a positive integer!\"</span><span class=\"p\">);</span>            <span class=\"k\">if</span> <span class=\"n\">precision</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>                <span class=\"nd\">panic!</span><span class=\"p\">(</span><span class=\"s\">\"Precision must be a positive integer!\"</span><span class=\"p\">);</span>            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">iterations</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>                <span class=\"nd\">panic!</span><span class=\"p\">(</span><span class=\"s\">\"Number of iterations must be a positive integer!\"</span><span class=\"p\">);</span>            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>                <span class=\"nd\">println!</span><span class=\"p\">(</span>                    <span class=\"s\">\"Approximation: {:?}\"</span><span class=\"p\">,</span>                    <span class=\"nf\">pi</span><span class=\"p\">(</span><span class=\"n\">precision</span> <span class=\"k\">as</span> <span class=\"nb\">u32</span><span class=\"p\">,</span> <span class=\"n\">iterations</span> <span class=\"k\">as</span> <span class=\"nb\">u32</span><span class=\"p\">)</span>                <span class=\"p\">);</span>                <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Precision:  {:?}\"</span><span class=\"p\">,</span> <span class=\"n\">precision</span><span class=\"p\">);</span>                <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Iterations: {:?}\"</span><span class=\"p\">,</span> <span class=\"n\">iterations</span><span class=\"p\">);</span>            <span class=\"p\">}</span>        <span class=\"p\">}</span>        <span class=\"mi\">_</span> <span class=\"k\">=&gt;</span> <span class=\"nd\">panic!</span><span class=\"p\">(</span><span class=\"s\">\"Redundant argument.\"</span><span class=\"p\">),</span>    <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></figure><p>To enhance utility, this thing runs on CLI using <code class=\"language-plaintext highlighter-rouge\">env</code>, allowing to specify the desired precision and number of iterations as straightforward command line arguments. Moreover, basic error handling exists, ensuring that a user can’t shoot themselves in the foot.</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\"><span class=\"o\">[</span>nail_@nailCPU src]<span class=\"nv\">$ </span>cargo run 1000 1warning: found module declaration <span class=\"k\">for </span>lib.rs  <span class=\"nt\">--</span><span class=\"o\">&gt;</span> src/main.rs:14:1   |14 | mod lib<span class=\"p\">;</span>   | ^^^^^^^^   |   <span class=\"o\">=</span> note: lib.rs is the root of this crate<span class=\"s1\">'s library target   = help: to refer to it from other targets, use the library'</span>s name as the path   <span class=\"o\">=</span> note: <span class=\"sb\">`</span><span class=\"c\">#[warn(special_module_name)]` on by default</span>warning: <span class=\"sb\">`</span>chudnovskys-amongii<span class=\"sb\">`</span> <span class=\"o\">(</span>bin <span class=\"s2\">\"chudnovskys-amongii\"</span><span class=\"o\">)</span> generated 1 warning    Finished dev <span class=\"o\">[</span>unoptimized + debuginfo] target<span class=\"o\">(</span>s<span class=\"o\">)</span> <span class=\"k\">in </span>0.16s     Running <span class=\"sb\">`</span>/home/nail_/Documents/Programming/chudnovskys-amongii/target/debug/chudnovskys-amongii 1000 1<span class=\"sb\">`</span>Approximation: 3.141592653589734207668453591578298340762233260915706590894145498737666209401659108066117347469689757798160379655566278035801345995935132861731766159828062231080441973785312530565152115747085933831774415457744154596022745876277128465914181337399228595357841129880883782421267946896335292166769473366196807151594471515944Precision:  1000Iterations: 1</code></pre></figure><p>It’s not perfect sure, but it sure does work. This small project really helped me wrap my head around Rust and Math (even though Math is a fluke in school) so go ahead and give it a try!</p><h2 id=\"links\">Links</h2><ul>  <li><strong><a href=\"https://github.com/nail-e/chudnovskys-amongii\">Github Page</a></strong></li>  <li><strong><a href=\"https://docs.rs/rug/latest/rug/\">Rug Library</a></strong></li>  <li><strong><a href=\"https://www.youtube.com/watch?v=dET2l8l3upU\">Stand-Up Math’s Video</a></strong></li></ul>",
            "url": "http://localhost:4000/in-search-of-amongi-using-rust-and-chudnovskys-algorithm/",
            
            
            
            "tags": ["software","math","coding","rust"],
            
            "date_published": "2023-10-13T04:00:00+04:00",
            "date_modified": "2023-10-13T04:00:00+04:00",
            
                "author": "Elian Rieza"
            
        },
    
        {
            "id": "http://localhost:4000/creating-an-arduino-powered-lightgate/",
            "title": "Creating an Arduino-Powered Lightgate",
            "summary": null,
            "content_text": "A high-school project never really warrants any extra brainpower required, especially if it’s ungraded and for competition but the time constraints and team pressure makes an absolutely great learning experience. Last month, my IB school decided to run a Group 4 project day(s) and well, other than the redundancy of an optional, 6-hour project stretched out to two days, the Arduino project went well for our group.The prompt for the project was to create systems for a city on Mars and our group came up with a transportation system that would speed through Martian planes in a hyperloop-esque system. As the “Computer Scientist” and “Physicist” of the group, I was tasked with creating a monitoring system for the hyperloop speeds and thus came the idea of creating a lightgate.A lightgate usually comes in pairs and is hooked up to a datalogger to either read the speed, velocity, acceleration or time between passing lightgates. To register a lightgate reading, the lightgate’s light sensor reading would usually deviate enough to suggest that an object has passed through the lightgate. Standard stuff.The project required calculating the speed of a train through the model tunnel, so fortunately for me, only one light sensor’s reading is required (thankfully). The KY-018 photoresistor module acts as the lightgate’s sensor. An LCD display also outputs the speed of the object passing through the tunnel.I attached the photoresistor to the two female-to-male connectors so that the photoresistor sensor head could be placed in a cardboard tube in the model.It seemed appropriate for female-to-male connectors could be used on the LEDs to allow it to be connected on the top of the cardboard tube for easier viewing (and also a more polished model).In the end, I sided with it as I was planning to exhibit the model headless and my group really didn’t want to lug around a behemoth of a gaming laptop just for this one exhibition.The code for the board should first check the average reading of the first 10 readings to get the mean reading of the brightness. This allows for any negative deviations to register as the lightgate being used. As one photoresistor is attached, the length of the object planned to pass through the lightgate must be declared (in km ⋅ h -1 ) to get an accurate speed reading so as the photoresistor’s digital value gets lower than a certain average threshold, a digital timer will start to calculate the time taken for the object to pass then the value is converted into hours. After this, the final value should be displayed on the LCD.This is when I realized that I was missing a potentiometer. I couldn’t find one in time so I decided to output the speed calculations on the computer instead and only use the LCD as a proof-of-concept. But all-in-all, writing the software for it was a breeze. The timer module for Arduino is an absolute godsend, using only two functions to be able to calculate time taken. I highly recommend it for anyone needing a timer function for Arduino.// This code comes from GitHub page#include &lt;LiquidCrystal.h&gt; LiquidCrystal lcd(12, 11, 5, 4, 3, 2); int threshold = 150;                      \t  const int count = 500; int readings[count];   int readIndex, total, photoresistor; int length = 0; // Length of object passing thru tube in metersvoid setup() {   Serial.begin(9600);          \t    lcd.begin(16,2);   lcd.clear();   for (int i = 0; i &lt; count; i++) {     readings[i] = 0;   } } void loop() {   total = total - readings[readIndex];   readings[readIndex] = analogRead(A0);   total = total + readings[readIndex];   readIndex = readIndex + 1;  if (readIndex &gt;= count) {     readIndex = 0;  }   photoresistor = analogRead(A0);      Serial.println(photoresistor);         if (photoresistor &lt; threshold) {     lcd.clear();     lcd.setCursor(0,0);     lcd.print(\"Lightgate Closed\");     lcd.setCursor(0,1);     lcd.print(length / readIndex);    lcd.setCursor(5,1);     lcd.print(\"m/s\");   }   else {     lcd.setCursor(0,0);     lcd.print(\"Lightgate Clear \");     readIndex = 0;   }   delay(100);               \t  } Future StuffOne glaring issue was the concession I made with the average reading. While this probably could’ve been easily fixed by writing each value to an array of 10, time constraints (and severe procrastination) hampered it. It probably could’ve been added in 10 mins with an extra 10 minutes just for testing.Lightgates are also usually upright but this one’s upside down. Lab-grade lightgates use invisible lasers to calculate when and how fast an object breaks or shortens a laser’s length so an analog sensor is caveman technology compared to a lab-grade lightgate.Another problem is how the timer was counted. If I were creating this in a non-Arduino environment, my first instinct would’ve been using difference in Unix time but I found as I found a solution in the Timer module, which is way easier than Unix time difference. Timer isn’t super efficient though, with a few tests showing different values for the same delay time but I guess 5 decimal places don’t really matter.Links  Github Page  Project Gallery",
            "content_html": "<p>A high-school project never really warrants any extra brainpower required, especially if it’s ungraded and for competition but the time constraints and team pressure makes an absolutely great learning experience. Last month, my IB school decided to run a Group 4 project day(s) and well, other than the redundancy of an optional, 6-hour project stretched out to two days, the Arduino project went well for our group.</p><p>The prompt for the project was to create systems for a city on Mars and our group came up with a transportation system that would speed through Martian planes in a hyperloop-esque system. As the “Computer Scientist” and “Physicist” of the group, I was tasked with creating a monitoring system for the hyperloop speeds and thus came the idea of creating a lightgate.</p><p><img src=\"/assets/images/lightgate-post/real.jpg\" alt=\"Arduino Lightgate\" title=\"Lightgate\" style=\"width:500px; height:300px; margin-right:20px; float: left;\" /></p><p>A lightgate usually comes in pairs and is hooked up to a datalogger to either read the speed, velocity, acceleration or time between passing lightgates. To register a lightgate reading, the lightgate’s light sensor reading would usually deviate enough to suggest that an object has passed through the lightgate. Standard stuff.</p><p>The project required calculating the speed of a train through the model tunnel, so fortunately for me, only one light sensor’s reading is required (thankfully). The KY-018 photoresistor module acts as the lightgate’s sensor. An LCD display also outputs the speed of the object passing through the tunnel.</p><p>I attached the photoresistor to the two female-to-male connectors so that the photoresistor sensor head could be placed in a cardboard tube in the model.</p><p>It seemed appropriate for female-to-male connectors could be used on the LEDs to allow it to be connected on the top of the cardboard tube for easier viewing (and also a more polished model).</p><p><img src=\"/assets/images/lightgate-post/FTM2.jpg\" alt=\"Arduino Lightgate\" title=\"Lightgate\" style=\"width:500px; height:300px; float: right; margin-left:20px\" /></p><p>In the end, I sided with it as I was planning to exhibit the model headless and my group really didn’t want to lug around a behemoth of a gaming laptop just for this one exhibition.</p><p>The code for the board should first check the average reading of the first 10 readings to get the mean reading of the brightness. This allows for any negative deviations to register as the lightgate being used. As one photoresistor is attached, the length of the object planned to pass through the lightgate must be declared (in <span class=\"unit\">km ⋅ h</span> <sup class=\"superscript\">-1</sup> ) to get an accurate speed reading so as the photoresistor’s digital value gets lower than a certain average threshold, a digital timer will start to calculate the time taken for the object to pass then the value is converted into hours. After this, the final value should be displayed on the LCD.</p><p>This is when I realized that I was missing a potentiometer. I couldn’t find one in time so I decided to output the speed calculations on the computer instead and only use the LCD as a proof-of-concept. But all-in-all, writing the software for it was a breeze. The timer module for Arduino is an absolute godsend, using only two functions to be able to calculate time taken. I highly recommend it for anyone needing a timer function for Arduino.</p><figure class=\"highlight\"><pre><code class=\"language-c\" data-lang=\"c\"><span class=\"c1\">// This code comes from GitHub page</span><span class=\"cp\">#include &lt;LiquidCrystal.h&gt; </span><span class=\"n\">LiquidCrystal</span> <span class=\"nf\">lcd</span><span class=\"p\">(</span><span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">);</span> <span class=\"kt\">int</span> <span class=\"n\">threshold</span> <span class=\"o\">=</span> <span class=\"mi\">150</span><span class=\"p\">;</span>                      \t  <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">500</span><span class=\"p\">;</span> <span class=\"kt\">int</span> <span class=\"n\">readings</span><span class=\"p\">[</span><span class=\"n\">count</span><span class=\"p\">];</span>   <span class=\"kt\">int</span> <span class=\"n\">readIndex</span><span class=\"p\">,</span> <span class=\"n\">total</span><span class=\"p\">,</span> <span class=\"n\">photoresistor</span><span class=\"p\">;</span> <span class=\"kt\">int</span> <span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c1\">// Length of object passing thru tube in meters</span><span class=\"kt\">void</span> <span class=\"nf\">setup</span><span class=\"p\">()</span> <span class=\"p\">{</span>   <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(</span><span class=\"mi\">9600</span><span class=\"p\">);</span>          \t    <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">);</span>   <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">clear</span><span class=\"p\">();</span>   <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">count</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>     <span class=\"n\">readings</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>   <span class=\"p\">}</span> <span class=\"p\">}</span> <span class=\"kt\">void</span> <span class=\"nf\">loop</span><span class=\"p\">()</span> <span class=\"p\">{</span>   <span class=\"n\">total</span> <span class=\"o\">=</span> <span class=\"n\">total</span> <span class=\"o\">-</span> <span class=\"n\">readings</span><span class=\"p\">[</span><span class=\"n\">readIndex</span><span class=\"p\">];</span>   <span class=\"n\">readings</span><span class=\"p\">[</span><span class=\"n\">readIndex</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">analogRead</span><span class=\"p\">(</span><span class=\"n\">A0</span><span class=\"p\">);</span>   <span class=\"n\">total</span> <span class=\"o\">=</span> <span class=\"n\">total</span> <span class=\"o\">+</span> <span class=\"n\">readings</span><span class=\"p\">[</span><span class=\"n\">readIndex</span><span class=\"p\">];</span>   <span class=\"n\">readIndex</span> <span class=\"o\">=</span> <span class=\"n\">readIndex</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">readIndex</span> <span class=\"o\">&gt;=</span> <span class=\"n\">count</span><span class=\"p\">)</span> <span class=\"p\">{</span>     <span class=\"n\">readIndex</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"p\">}</span>   <span class=\"n\">photoresistor</span> <span class=\"o\">=</span> <span class=\"n\">analogRead</span><span class=\"p\">(</span><span class=\"n\">A0</span><span class=\"p\">);</span>      <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"n\">photoresistor</span><span class=\"p\">);</span>         <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">photoresistor</span> <span class=\"o\">&lt;</span> <span class=\"n\">threshold</span><span class=\"p\">)</span> <span class=\"p\">{</span>     <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">clear</span><span class=\"p\">();</span>     <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">setCursor</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">);</span>     <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"Lightgate Closed\"</span><span class=\"p\">);</span>     <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">setCursor</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">);</span>     <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">length</span> <span class=\"o\">/</span> <span class=\"n\">readIndex</span><span class=\"p\">);</span>    <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">setCursor</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">);</span>     <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"m/s\"</span><span class=\"p\">);</span>   <span class=\"p\">}</span>   <span class=\"k\">else</span> <span class=\"p\">{</span>     <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">setCursor</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">);</span>     <span class=\"n\">lcd</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"Lightgate Clear \"</span><span class=\"p\">);</span>     <span class=\"n\">readIndex</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>   <span class=\"p\">}</span>   <span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">);</span>               \t  <span class=\"p\">}</span> </code></pre></figure><h2 id=\"future-stuff\">Future Stuff</h2><p>One glaring issue was the concession I made with the average reading. While this probably could’ve been easily fixed by writing each value to an array of 10, time constraints (and severe procrastination) hampered it. It probably could’ve been added in 10 mins with an extra 10 minutes just for testing.</p><p>Lightgates are also usually upright but this one’s upside down. Lab-grade lightgates use invisible lasers to calculate when and how fast an object breaks or shortens a laser’s length so an analog sensor is caveman technology compared to a lab-grade lightgate.</p><p>Another problem is how the timer was counted. If I were creating this in a non-Arduino environment, my first instinct would’ve been using difference in Unix time but I found as I found a solution in the Timer module, which is way easier than Unix time difference. Timer isn’t super efficient though, with a few tests showing different values for the same delay time but I guess 5 decimal places don’t really matter.</p><h2 id=\"links\">Links</h2><ul>  <li><strong><a href=\"https://github.com/nail-e/arduino-lightgate\">Github Page</a></strong></li>  <li><strong><a href=\"https://github.com/nail-e/arduino-lightgate/tree/main/Gallery\">Project Gallery</a></strong></li></ul>",
            "url": "http://localhost:4000/creating-an-arduino-powered-lightgate/",
            
            
            
            "tags": ["arduino","physics","hardware"],
            
            "date_published": "2023-04-13T04:00:00+04:00",
            "date_modified": "2023-04-13T04:00:00+04:00",
            
                "author": "Elian Rieza"
            
        },
    
        {
            "id": "http://localhost:4000/this-is-a-blog/",
            "title": "This is a Blog",
            "summary": null,
            "content_text": "Hello. I’m Elian, or nail-e, and this is my blog.A blog to collect and share all my tech/nerd ideas was something I’ve always had in mind but couldn’t get around doing but finally, after months of deliberation and mental preperation, I finally got some HTML running, stripped and rewrote CSS, hacked stylesheets online and collated all my posts ideas on Obsidian to be uploaded here.Stay tuned :)",
            "content_html": "<p>Hello. I’m Elian, or nail-e, and this is my blog.</p><p>A blog to collect and share all my tech/nerd ideas was something I’ve always had in mind but couldn’t get around doing but finally, after months of deliberation and mental preperation, I finally got some HTML running, stripped and rewrote CSS, hacked stylesheets online and collated all my posts ideas on Obsidian to be uploaded here.</p><p>Stay tuned :)</p>",
            "url": "http://localhost:4000/this-is-a-blog/",
            
            
            
            "tags": ["General","Random"],
            
            "date_published": "2022-06-21T04:00:00+04:00",
            "date_modified": "2022-06-21T04:00:00+04:00",
            
                "author": "Elian Rieza"
            
        }
    
    ]
}